/**
 * Runtime config for service: web (with deep dependencies)
 * Generated by: tsops prune web --include-transitive
 * 
 * This includes all transitive dependencies:
 * web -> api -> database, cache
 * web -> auth -> database  
 * web -> observability
 */

export interface ServiceInfo {
  name: string
  kind: 'gateway' | 'api' | 'worker' | 'database' | 'cache'
  image: string
  internalUrl: string
  externalUrl?: string
  port: number
  dependencies: string[]
  environment: Record<string, string>
  secrets: Record<string, string>
  configMaps: Record<string, string>
  resources: {
    cpu: string
    memory: string
  }
}

export interface NetworkTopology {
  services: Record<string, ServiceInfo>
  connections: Array<{
    from: string
    to: string
    port: number
    protocol: string
  }>
}

export const topology: NetworkTopology = {
  services: {
    web: {
      name: 'web',
      kind: 'gateway',
      image: 'ghcr.io/org/hyper-graph-web:abc123',
      internalUrl: 'http://hyper-graph-web.prod.svc.cluster.local:8080',
      externalUrl: 'https://example.com',
      port: 8080,
      dependencies: ['api', 'auth', 'observability'],
      environment: {
        NODE_ENV: 'production',
        PORT: '8080',
        API_URL: 'http://hyper-graph-api.prod.svc.cluster.local:8080',
        AUTH_URL: 'http://hyper-graph-auth.prod.svc.cluster.local:8081',
        OBSERVABILITY_URL: 'http://hyper-graph-observability.prod.svc.cluster.local:4318'
      },
      secrets: {
        JWT_SECRET: 'super-secret-jwt-key',
        API_KEY: 'api-key-12345'
      },
      configMaps: {
        LOG_LEVEL: 'info',
        FEATURE_FLAGS: '{"newUI": true}'
      },
      resources: {
        cpu: '100m',
        memory: '128Mi'
      }
    },
    
    api: {
      name: 'api',
      kind: 'api', 
      image: 'ghcr.io/org/hyper-graph-api:abc123',
      internalUrl: 'http://hyper-graph-api.prod.svc.cluster.local:8080',
      port: 8080,
      dependencies: ['database', 'cache'],
      environment: {
        NODE_ENV: 'production',
        PORT: '8080',
        DATABASE_URL: 'postgresql://user:pass@hyper-graph-database.prod.svc.cluster.local:5432/hypergraph',
        REDIS_URL: 'redis://hyper-graph-cache.prod.svc.cluster.local:6379'
      },
      secrets: {
        DATABASE_PASSWORD: 'db-password-123',
        JWT_SECRET: 'super-secret-jwt-key'
      },
      configMaps: {
        LOG_LEVEL: 'info',
        API_RATE_LIMIT: '1000'
      },
      resources: {
        cpu: '500m',
        memory: '512Mi'
      }
    },
    
    auth: {
      name: 'auth',
      kind: 'api',
      image: 'ghcr.io/org/hyper-graph-auth:abc123', 
      internalUrl: 'http://hyper-graph-auth.prod.svc.cluster.local:8081',
      port: 8081,
      dependencies: ['database'],
      environment: {
        NODE_ENV: 'production',
        PORT: '8081',
        DATABASE_URL: 'postgresql://user:pass@hyper-graph-database.prod.svc.cluster.local:5432/hypergraph'
      },
      secrets: {
        JWT_SECRET: 'super-secret-jwt-key',
        OAUTH_CLIENT_SECRET: 'oauth-secret-123'
      },
      configMaps: {
        LOG_LEVEL: 'info',
        SESSION_TIMEOUT: '3600'
      },
      resources: {
        cpu: '200m',
        memory: '256Mi'
      }
    },
    
    database: {
      name: 'database',
      kind: 'database',
      image: 'postgres:15',
      internalUrl: 'hyper-graph-database.prod.svc.cluster.local:5432',
      port: 5432,
      dependencies: [],
      environment: {
        POSTGRES_DB: 'hypergraph',
        POSTGRES_USER: 'user',
        POSTGRES_PASSWORD: 'db-password-123'
      },
      secrets: {
        POSTGRES_PASSWORD: 'db-password-123'
      },
      configMaps: {
        POSTGRES_INITDB_ARGS: '--auth-host=scram-sha-256'
      },
      resources: {
        cpu: '1000m',
        memory: '1Gi'
      }
    },
    
    cache: {
      name: 'cache',
      kind: 'cache',
      image: 'redis:7',
      internalUrl: 'hyper-graph-cache.prod.svc.cluster.local:6379',
      port: 6379,
      dependencies: [],
      environment: {
        REDIS_PASSWORD: 'redis-password-123'
      },
      secrets: {
        REDIS_PASSWORD: 'redis-password-123'
      },
      configMaps: {
        REDIS_MAXMEMORY: '256mb'
      },
      resources: {
        cpu: '100m',
        memory: '256Mi'
      }
    },
    
    observability: {
      name: 'observability',
      kind: 'worker',
      image: 'ghcr.io/org/hyper-graph-observability:abc123',
      internalUrl: 'http://hyper-graph-observability.prod.svc.cluster.local:4318',
      port: 4318,
      dependencies: [],
      environment: {
        NODE_ENV: 'production',
        PORT: '4318',
        OTEL_EXPORTER_OTLP_ENDPOINT: 'http://jaeger-collector.prod.svc.cluster.local:14268'
      },
      secrets: {},
      configMaps: {
        LOG_LEVEL: 'info',
        SAMPLING_RATE: '0.1'
      },
      resources: {
        cpu: '100m',
        memory: '128Mi'
      }
    }
  },
  
  connections: [
    { from: 'web', to: 'api', port: 8080, protocol: 'http' },
    { from: 'web', to: 'auth', port: 8081, protocol: 'http' },
    { from: 'web', to: 'observability', port: 4318, protocol: 'http' },
    { from: 'api', to: 'database', port: 5432, protocol: 'tcp' },
    { from: 'api', to: 'cache', port: 6379, protocol: 'tcp' },
    { from: 'auth', to: 'database', port: 5432, protocol: 'tcp' }
  ]
}

// Helper functions
export function getService(name: string): ServiceInfo | undefined {
  return topology.services[name]
}

export function getDependencies(serviceName: string): ServiceInfo[] {
  const service = topology.services[serviceName]
  if (!service) return []
  
  return service.dependencies
    .map(depName => topology.services[depName])
    .filter(Boolean)
}

export function getTransitiveDependencies(serviceName: string): ServiceInfo[] {
  const visited = new Set<string>()
  const result: ServiceInfo[] = []
  
  function collectDeps(name: string) {
    if (visited.has(name)) return
    visited.add(name)
    
    const service = topology.services[name]
    if (!service) return
    
    for (const depName of service.dependencies) {
      result.push(topology.services[depName])
      collectDeps(depName)
    }
  }
  
  collectDeps(serviceName)
  return result
}

export function getConnection(from: string, to: string) {
  return topology.connections.find(conn => conn.from === from && conn.to === to)
}

// Type-safe service names
export type ServiceName = keyof typeof topology.services

// Example usage:
// const apiService = getService('api')
// const webDeps = getDependencies('web') 
// const allDeps = getTransitiveDependencies('web')
// const webToApi = getConnection('web', 'api')