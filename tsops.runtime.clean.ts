/**
 * Clean runtime config for service: web
 * Generated by: tsops prune web
 * 
 * Principles:
 * 1. No secret values - only Kubernetes references
 * 2. Only direct dependencies - web doesn't know about database
 * 3. Minimal data - only what web service actually needs
 */

export interface ServiceInfo {
  name: string
  kind: 'gateway' | 'api' | 'worker' | 'database' | 'cache'
  image: string
  internalUrl: string
  externalUrl?: string
  port: number
  resources: {
    cpu: string
    memory: string
  }
}

export interface DependencyInfo {
  service: string
  url: string
  port: number
  protocol: 'http' | 'https' | 'tcp' | 'udp'
  description?: string
}

export interface EnvironmentReference {
  type: 'static' | 'secret' | 'configmap' | 'env'
  value?: string
  secretName?: string
  secretKey?: string
  configMapName?: string
  configMapKey?: string
  envVar?: string
}

export interface RuntimeConfig {
  project: 'hyper-graph'
  namespace: 'prod'
  domain: 'example.com'
  
  // Current service info
  service: ServiceInfo
  
  // Only direct dependencies (what web actually calls)
  dependencies: DependencyInfo[]
  
  // Environment variable references (not values!)
  environment: Record<string, EnvironmentReference>
  
  // Network configuration
  network: {
    ingress: {
      host: string
      tls: boolean
      className: string
    }
  }
}

export const config: RuntimeConfig = {
  project: 'hyper-graph',
  namespace: 'prod',
  domain: 'example.com',
  
  // Web service itself
  service: {
    name: 'web',
    kind: 'gateway',
    image: 'ghcr.io/org/hyper-graph-web:abc123',
    internalUrl: 'http://hyper-graph-web.prod.svc.cluster.local:8080',
    externalUrl: 'https://example.com',
    port: 8080,
    resources: {
      cpu: '100m',
      memory: '128Mi'
    }
  },
  
  // Only services that web directly calls
  dependencies: [
    {
      service: 'api',
      url: 'http://hyper-graph-api.prod.svc.cluster.local:8080',
      port: 8080,
      protocol: 'http'
    },
    {
      service: 'auth',
      url: 'http://hyper-graph-auth.prod.svc.cluster.local:8081',
      port: 8081,
      protocol: 'http'
    },
    {
      service: 'observability',
      url: 'http://hyper-graph-observability.prod.svc.cluster.local:4318',
      port: 4318,
      protocol: 'http',
      description: 'OTLP collector'
    }
  ],
  
  // Environment variables - only references, no values
  environment: {
    // Static values
    NODE_ENV: {
      type: 'static',
      value: 'production'
    },
    PORT: {
      type: 'static',
      value: '8080'
    },
    DOMAIN: {
      type: 'static',
      value: 'example.com'
    },
    
    // Service URLs (computed from dependencies)
    API_URL: {
      type: 'static',
      value: 'http://hyper-graph-api.prod.svc.cluster.local:8080'
    },
    AUTH_URL: {
      type: 'static',
      value: 'http://hyper-graph-auth.prod.svc.cluster.local:8081'
    },
    OBSERVABILITY_URL: {
      type: 'static',
      value: 'http://hyper-graph-observability.prod.svc.cluster.local:4318'
    },
    
    // Secret references (Kubernetes will resolve these)
    JWT_SECRET: {
      type: 'secret',
      secretName: 'web-secrets',
      secretKey: 'JWT_SECRET'
    },
    API_KEY: {
      type: 'secret',
      secretName: 'web-secrets',
      secretKey: 'API_KEY'
    },
    
    // ConfigMap references (Kubernetes will resolve these)
    LOG_LEVEL: {
      type: 'configmap',
      configMapName: 'web-config',
      configMapKey: 'LOG_LEVEL'
    },
    FEATURE_FLAGS: {
      type: 'configmap',
      configMapName: 'web-config',
      configMapKey: 'FEATURE_FLAGS'
    },
    
    // Environment variable references
    DEBUG: {
      type: 'env',
      envVar: 'DEBUG'
    }
  },
  
  network: {
    ingress: {
      host: 'example.com',
      tls: true,
      className: 'nginx'
    }
  }
}

// Helper functions
export function getDependency(serviceName: string): DependencyInfo | undefined {
  return config.dependencies.find(dep => dep.service === serviceName)
}

export function getDependencyUrl(serviceName: string): string | undefined {
  return getDependency(serviceName)?.url
}

export function getEnvironmentVar(key: string): EnvironmentReference | undefined {
  return config.environment[key]
}

export function getStaticEnvVar(key: string): string | undefined {
  const envVar = config.environment[key]
  return envVar?.type === 'static' ? envVar.value : undefined
}

export function getSecretRef(key: string): { secretName: string; secretKey: string } | undefined {
  const envVar = config.environment[key]
  return envVar?.type === 'secret' && envVar.secretName && envVar.secretKey
    ? { secretName: envVar.secretName, secretKey: envVar.secretKey }
    : undefined
}

export function getConfigMapRef(key: string): { configMapName: string; configMapKey: string } | undefined {
  const envVar = config.environment[key]
  return envVar?.type === 'configmap' && envVar.configMapName && envVar.configMapKey
    ? { configMapName: envVar.configMapName, configMapKey: envVar.configMapKey }
    : undefined
}

// Type-safe dependency names
export type DependencyName = typeof config.dependencies[number]['service']

// Example usage in application code:
// const apiUrl = getDependencyUrl('api')
// const authUrl = getDependencyUrl('auth')
// const jwtSecretRef = getSecretRef('JWT_SECRET')
// const logLevel = getStaticEnvVar('LOG_LEVEL')